	% !TEX encoding = UTF-8 Unicode

	\documentclass[a4paper]{article}

	\usepackage{color}
	\usepackage{url}
	\usepackage[T2A]{fontenc} % enable Cyrillic fonts
	\usepackage[utf8]{inputenc} % make weird characters work
	\usepackage{graphicx}

	\usepackage[english,serbian]{babel}
	%\usepackage[english,serbianc]{babel} %ukljuciti babel sa ovim opcijama, umesto gornjim, ukoliko se koristi cirilica

	\usepackage[unicode]{hyperref}
	\hypersetup{colorlinks,citecolor=green,filecolor=green,linkcolor=blue,urlcolor=blue}

	%\newtheorem{primer}{Пример}[section] %ćirilični primer
	\newtheorem{primer}{Primer}[section]

	\begin{document}

	\title{Temporalne logike\\ \small{Seminarski rad u okviru kursa\\Metodologija stručnog i naučnog rada\\ Matematički fakultet}}

	\author {Đorđe Todorović, Stefan Zarić, Maksim Đurđevac\\ mi12090@matf.bg.ac.rs, mi11362@alas.matf.bg.ac.rs}
	\date{8.~april 2017.}
	\maketitle

	\abstract{
	Ovaj seminarski rad obrađuje temu temporalne logike, zapravo upotrebu logike u računarstvu,za čiju upotrebu
	veoma bitnu ulogu ima vreme.
	Preciznije su opisane osnove linarne temporalne logike (LTL) i logike stabla 
	izračunavanja (CTL), osnovne primene ovih logika, takođe su navedeni i najpoznatiji alati za proveravanje modela,
	kao i ukratko mogućnosti alata ESBMC i neki primeri njegovih upotreba.

	\tableofcontents

	\newpage

	\section{Uvod}
	\label{sec:uvod}

	Glavni cilj upotrebe logike u računarstvu je da se razviju jezici koji modeluju situacije koje srećemo kao profesionalci
	u toj oblasti, u nekom formalnom obliku. Razlozi za to su da damo formalne pravila za prepoznavanje koji su argumenti ispravni,tj. validni, a koji ne. Uska je povezanost pojmova Temporalna logika i iskazna logika, gde takodje imamo jasno definisanu sintaksu i semantiku. Jezici u matematici su pretezno simbolički, sto će reći da kombinovanjem istih dobijamo izraze koji predstavljaju odredjene matematićke objekte. Sintaksa jezika definise skup validnih simbola koji se mogu upotrebljavati kako bi se kreirali takodje validni izrazi. Semtantika se bavi tumačenjem izraza. Iskazna logika (i predikarska logika) je dobra za opisivanje matematičkih problema koje srećemo u teoriji, ali cesto imamo potrebu za opisivanjem i modelovanjem problema koje srećemo svakodnevno u životu. Temporalne logike su logike koje opisuju rezonovanja u kojima je uključeno i vreme. Primena ovih logika je sve veća kako kod softverskih rešenja, tako i kod kreiranja samog hardvera.\newline
	
	Temporalne logike su sve značajnije u oblasti Informacionih tehnologija, tj. računarstvu, jer se ponašanje i hardvera i softvera opisuje u zavisnosti od vremena. Rad operativnih sistema, funkcionisanje konkurentnih sistema, rad procesora, memorije itd. Vreme u temporalnoj logici modelujemo upotrebom različitih operatora. Osnovne vrste ovih logika jesu Linearne temporalne logike(LTL) i Logike stabla odlučivanja(CTL), ali u daljem tekstu će ova dve vrste biti detaljnije obrađene.

	\section{Linearne temporalne logike}
	\label{sec:LTL}

	\newline
	Kao što smo već napomenuli, temporalne logike uključuju u razmatranje  vreme, i takođe smo pomenuli neke osnovne vrste ovih logika, pa stoga ćemo prvo opisati LTL model, linearne temporalne logike, koje vreme posmatraju kao sekvence koje se linearno ređaju jedna za drugom. Linearne temporalne logike predstavljaju beskonačan niz sekvenci gde u svakom trenutku svaka od njih ima svog naslednika, na osnovu linearne vremenske perspektive. Uvodimo i pojam 'linearno temporalno svojstvo' koje predstavlja temporalnu logičku formulu koja opisuje skup beskonačnih sekvenci koje su tačne, tj. imaju vrednost 'True'.\newline

	Svrha LTL-a jeste da se svojstva napisana u prirodnom jeziku prevedu u LTL uz pomoć precizno definisane sintakse. Ovu logiku odlikuje pojava različitih operatora, čijom upotrebom možemo opisati razne modele vremena, ali nama će za sada biti interesantni samo operatori koji opisuju linearne sekvence. Postoje i tkzv. univerzalni logički veznici, kojima možemo opisati svako temporalnu logiku.
	\subsection{Sintaksa}
	\label{subsec:podnaslovN}
	\newline
	
Sintaksa jezika proučava pravila koja određuju kako se elementi tog jezika na pravilan način mogu kombinovati i stvarati takođe ispravni element. Kombinacijom operatora i iskaznih slova dobijamo logičke formule.\newline\newline Formula linearne temporalne logike je sačinjena od: \newline \newline
		1) Konačnog skupa atoma (a, b, x, y, ....) \newline
		2) Osnovnih logičkih operatora (¬ (negation) , ∧ (conjunction)) \newline
		3) Osnovnih temporalnih operatora (O (next) , U (until) , true) \newline
		4) Postoje i dodatni logički operatori (∨ (disjunction), →(implication), ↔(equivalence)) \newline
		5) Postoje i dodatni temporalni operatori ( □ (”always”) ♦ (”eventually”)) \newline

	Kombinacijom navedenih možemo dobiti složenije operatore. Stoga ćemo navesti još neka pravila:\newline \newline
		7) ♦ -> 'F', što znači nešto konačno u budućnosti \newline
		8) □ -> 'G', što znači nešto globalno u budućnosti \newline
		9) ○ -> 'X', što znači nešto sledeći put \newline

	LTL može biti prošireno sa operatorima prošlosti: \newline \newline
		9) □-1 -> Uvek u prošlosti \newline
		10) ♦-1 -> Ponekad u prošlosti \newline
		11) ○-1 -> Prethodna sekvenca \newline\newline
		Takođe ćemo napomenuti i pravila 'weak until' i 'release':\newline
	1) Weak until (a W b) \newline
		-a ostaje True dok b ne postane True, pri tom može zauvek ostati True (ne zahteva se da b ikad postane True)
	2) Release (a R b) \newline
		-b ostaje True dok a ne postane True, pri tom može zauvek ostati True (ne zahteva se da b ikad postane True) znači suprotno od prethodnog \newline

	\subsection{Semantika}
	\label{subsec:podnaslovN}
	\newline
	Sintaksa logike je definisala kako nešto možemo zapisati ispravno, a semantika daje značenje istom.
	Vrste sistema koje obično modelujemo uz pomoć LTL-a možemo nazvati translacionim sistemima (TS). Razaznajemo pojmove stanica, sto predstavlja statičku strukturu i trannziciju, sto predstavlja dinamičku strukturu.
	LTL formula φ označava svojstva puteva (eng. traces) i jedan konkretan put moze biti potpuna LTL formula a i ne mora.
	Semantika formule φ je definisana kao jezik(φ) gde on sadrži beskonačnan skup reči koje zadovoljavaju φ.

	TS zadovoljava LT svojstvo P ako svi njegove stanice zadovoljavaju P, tj. ako sva njegova ponašanja jesu prihvatljiva. A stanica zadovoljava P kadgod svi putevi koji su krenuli iz te stanice zadovoljavaju P.

	TS zadovoljava ϕ ako TS zadovoljava LT svojstva dedfinisana na Jezik(ϕ).
	}

	\section{Logike stabla izracunavanja}
	\label{sec:CTL}
	\newline
	U LTL analizi smo zapazili da je LTL formula evaluirana preko puteva(eng. paths). Definisali smo da je stanica(eng. state) sistema
	zadovoljava jednu LTL formulu ako svi putevi iz te stanice(eng. state) zadovoljavaju istu. U ovoj strukturi drveta budući koraci još nisu
	odredjeni, jer postoji više puteva koji potencijalno mogu biti 'iskorišćena'.
	CTL nam omogućava da prebrodimo neke nedostatke LTL metoda. Kao i u LTL imamo operatore U, F, G i X, takodje imamo i kvantifikatore
	A i E koji opisuju sve puteve(eng. all paths) i postojeće puteve (eng. exists paths). 
	\newline
	\newline
	\subsection{Sintaksa}
	\label{subsec:podnaslovN}
	\newline
	CTL (eng. Computation tree logic) koristi logiku stabla pri izračunavanju. 
	Kao pre, radimo sa konačnim skupom atomičkih formula (kao što su p, q, r,...,p1,p2,p3...).

	Definišemo CTL formulu:

	ϕ ::= T | neT | p | (neϕ) | (ϕ /\ ϕ) | (ϕ \/ ϕ) | (ϕ -> ϕ) | AXϕ | EXϕ | Afϕ | EFϕ | AGϕ | EGϕ | A[ϕ U ϕ] | E[ϕ U ϕ]

	gde je p iz konačkog skupa atomičkih formula.
	\newline
	
	\subsection{Semantika}
	\label{subsec:podnaslovN}
	\newline

	CTL formula je interpretirana preko tranzicionog sistema (TS). Neka je M = (S, ->, L) neki model, s e S i ϕ CTL formula.
	Definicija modela bi bila sledeća:

		1) Ako je ϕ atomička, zadovoljivost je razrešena preko L \newline
		2) Ako veznik najvišeg prioriteta formule ϕ je bulovski veznik tada se pitanje zadovoljivosti razrešava
		   preko uobičajne istinitosne tablice i rekurzije nad drvetom formule ϕ \newline
		3) Ako je veznik najvišeg prioriteta neki operator koji počinje sa A, tada zadovoljivost jeste ispunjena ako
		   svi putevi iz s zadovoljavaju LTL formulu koja se dobija kada izbacimo simbol A \newline
		4) Slično ako je veznik najvišeg prioriteta neki operator koji počinje sa E, ada zadovoljivost jeste ispunjena ako
		   svi putevi iz s zadovoljavaju LTL formulu koja se dobija kada izbacimo simbol E \newline


	\section{Primena temporalnih logika u proveravanju modela}
	\label{sec:MC}

	Temporalna logika ima primenu u formalnoj verifikaciji sistema, pre svega u konkurentnim programima gde je bitno utvrditi da se program ne moze naci u stanju deadlocka. 
	Provera modela je tehnika za automatsku verifikaciju softvera i hardvera. Proverava se da li sistem ispunjava specifikaciju koja je zadata formulom temporalne logike. 
	Svaki zahtev u specifikaciji moze se predstaviti jednom formulom linearne temporalne logike i moze se nezavisno proveriti da li je ispunjen za dati sistem. Konjunkcija svih zahteva predstavlja specifikaciju sistema.
	Program predstavljamo kao konacni automat, i proveravamo da li je formula temporalne logike tacna u toj strukturi, odnosno da li program ispunjava specifikaciju.
	Algoritam linearne temporalne logike za proveru modela je procedura koja vraca "da" za dati tranzicioni sistem TS i formulu ϕ ako je TS |= ϕ, odnosno "ne" ako TS nije model formule ϕ.

	Prednosti i mane koriscenja provere modela.

	Prednosti: \newline
	- Nema potrebe za formalnim dokazima korektnosti. \newline
	- Brzina, u poredjenju sa drugim metodima verifikacije. \newline
	- Ako specifikacija nije zadovoljena bice generisan kontraprimer koji ce pokazati zasto specifikacija nije ispunjena. \newline
	- Moguce je proveriti ispunjenost zahteva i pre nego sto je ceo sistem zavrsen, tako da se moze vrsiti provera modela tokom izrade veceg sistema. \newline
	- Koriscenjem linearnih temporalnih logika mogu se iskazati svojstva konkurentnih programa koja su nam potrebna u automatskoj verifikaciji. \newline
	Mane: \newline
	- Zadavanje specifikacija formulama linearne temporalne logike moze da bude komplikovano. \newline
	- Pisanje specifikacija je tesko i mali broj inzenjera je obucen za formalnu verifikaciju sistema. \newline
	- Broj stanja u kome sistem moze da se nadje moze biti izuzetno velik, pogotovu ako radimo proveru modela na sistemima na kojima imamo konkurentnost. \newline

	Algoritam za proveru modela upotrebom automata i linearne temporalne logike

	Ulaz: konacni automat (tranzicioni sistem TS) i LTL formula ϕ \newline
	Izlaz: "da" ako je TS |= ϕ; inace, “ne” i generisan kontraprimer \newline

	Konstruisati NBA[\ref] A¬ϕ tako da Lω(A¬ϕ) = Words(¬ϕ) \newline
	Konstruisati tranzicioni sistem TS⊗A \newline

	if postoji put π u TS⊗A koji zadovoljava uslov ispunjenosti A then \newline
	return "ne" i an expressive prefix of π \newline
	else \newline
	return "da" \newline
	fi \newline

	\section{Slike i tabele}
	\label{slike_i_tabele}

	Slike i tabele treba da budu u svom okruženju, sa odgovarajućim naslovima, obeležene labelom da koje omogućava referenciranje. 

	\begin{primer} Ovako se ubacuje slika. Obratiti pažnju da je dodato i 
	\begin{verbatim}
	\usepackage{graphicx}
	\end{verbatim}

	\begin{figure}[h!]
	\begin{center}
	\includegraphics[scale=0.75]{panda.jpg}
	\end{center}
	\caption{Pande}
	\label{fig:pande}
	\end{figure}

	Na svaku sliku neophodno je referisati se negde u tekstu. Na primer, na slici \ref{fig:pande} prikazane su pande. 
	\end{primer}

	\begin{primer} I tabele treba da budu u svom okruženju, i na njih je neophodno referisati se u tekstu. Na primer, u tabeli \ref{tab:tabela1} su prikazana različita poravnanja u tabelama.

	\begin{table}[h!]
	\begin{center}
	\caption{Razlčita poravnanja u okviru iste tabele ne treba koristiti jer su nepregledna.}
	\begin{tabular}{|c|l|r|} \hline
	centralno poravnanje& levo poravnanje& desno poravnanje\\ \hline
	a &b&c\\ \hline
	d &e&f\\ \hline
	\end{tabular}
	\label{tab:tabela1}
	\end{center}
	\end{table}

	\end{primer}





	\section{ESBMC verifikacioni alat}
	\label{sec:ESBMC}

	U dizajnu kompleksnih softverskih sistema više se truda i vremena potroši na
	verifikaciju nego na kontrukciju samog softvera. Verifikacione tehnike  zasnovane na modelima se baziraju na modelima koji opisuju ponašanje sistema na matematički precizan i nedvosmislen način. Ispostavilo se da pre bilo kakvih verifikacionih provera, precizno modelovanje sistema često dovodi do otkrivanja nepravilnosti, nepotpunosti i nelogičnosti u neformalnim specifikacijama sistema. Takvi problemi se obično otkrivaju u kasnim fazama dizajna.Modeli sistema su praćeni algoritmima koji sistematično istražuju sva njihova stanja. To je preduslov za čitav niz tehnika verifikacije polazeći od provera modela preko simulacije do testiranja.
	Provera modela je verifikaciona tehnika koja istražuje sva moguća stanja sistema koristeći brute-force način.
	\newline
	ESBMC je kontekstno-ograničeni kontrolor modela za ugrađeni C/C++ softver, baziran na SMT (eng. satisﬁability modulo theory) rešavaču.  On dozvoljava verifikacionom inženjeru da: 
	\newline
	\begin{enumerate}
	\item Verifikuje jedno- i višenitni softver (sa deljenim promenljivama i                       međusobnim isključenjem);
	\item Prosuđuje o aritmetičkim prekoračenjima, bezbednosti pokazivača, curenju               memorije, granicama nizova, kršenju atomičnosti i redosleda izvršavanja,             mrtvim blokadama i utrkivanjima; 
	\item Verifikuje programe koji koriste aritmetiku na nivou bita, pokazivača,                  struktura, unija i sa fiksnim zarezom.
	\end{enumerate}
	ESBMC ne zahteva od korisnika da komentariše programe sa preduslovima i postuslovima (eng. pre/post-conditions), već mu dozvoljava da navede dodatna svojstva koristeći assert-instrukcije, koje se potom kontrolišu. Takođe, obezbeđuje tri pristupa (lenji, snimanje po rasporedu, podaproksimaciju i proširivanje) za kontrolu modela višenitnog softvera. ESBMC može biti pozivan kroz tekstualni komandni interfejs ili podešen putem dodatka za Eclipse. ESBMC obrađuje verifikacione uslove koristeći različite pozadinske teorije i prosleđuje ih direktno u SMT rešavač. Dodatno, ESBMC može da vrati vrednost verifikacionih uslova koristeći.
	\newline
	Podrazumevano, ESBMC proverava da li ima nepravilnosti u samom programskom jeziku, po ISO/ANSI programskom standardu.. Naravno, program može da bude ispravan, ali da ima pogrešnih stvari. Kod takvih slučajeva se dodaju dodatne specifikacije za program koristeći assert instrukcije. 
	\newline
	ESBMC  koristi transformacije  da pretvori program u niz matematičkih ograničenja:
	\begin{enumerate}
	\item Komponente biblioteka su objedinjene u programski tekst.
	\item Kontrola toka se pretvara u jednostavnu GOTO formu.
	\item GOTO program se prevodi u formu  u kojoj se zahteva da je promenljivoj dodeljena vrednost tačno jednom i svaka promenljiva je definisana, pre korišćenja.U ovoj fazi smo se pomerili sa predstavljanja C promenljive u promenljivu koja algebarsku nepoznatu povezuje sa svakim izvršenjem jednog zadatka.
	\item Uvodimo dodatna ograničenja izmedju nepoznatih, koja jedino mogu biti zadovoljena ako program ima grešku.
	\item SMT(eng. satisﬁability modulo theory) rešavač se pokreće da istraži da li sva ograničenja mogu biti zadovoljena odjednom. Bilo koji uspeh je greška u programu.
	\item Ako SMT solver uspe(program ne prolazi)koristimo njegovo uspešno dodeljivanje promenljive nepoznatoj da zaključimo pogrešan tok programa.
	\end{enumerate}
	Za ovaj primer programa:
	\newline
	\begin{primer}

	\newline \#include  <stdlib.h>  
	\newline
	int main()
	\newline
	\{
	\newline
		 unsigned int size = nondet_int();
	\newline
		char *hunk = malloc(size); 
		\newline
		unsigned int pos = nondet_int(); 
		\newline
		hunk[pos] = 0; return 0;
		\newline
	\}


	Generiše se sledeći izveštaj:
	\newline
	Violated property: file test.c line 10 function main dereference failure: dynamic object upper bound !(\_\_ESBMC\_is\_dynamic[POINTER\_OBJECT(hunk + pos)] \&\& DYNAMIC\_SIZE(hunk + pos) <= POINTER\_OFFSET(hunk) + pos) VERIFICATION FAILED
	\end{primer}


	\subsection{Primena}
	\label{subsec:Primena}

	Verifikacija softvera može imati različite primene.  Najčeća primena alata za verifikaciju je u oblasti  gde je ispravnost programa izrazito važna. 


	\section{Najpoznatiji alati za proveru modela}
\label{sec:NazpM}

Neki od napoznatijih alata za proveru modela su:
\begin{enumerate}
\item ARC
\item BANDERA
\item BLAST
\item CADENCE SMV
\item CADP
\item CBMC
\item CPAchecker
\item CWB-NC
\item DIVINE
\item DREAM
\item DSVerifier
\item EBMC
\item Edinburgh CWB
\item EmbeddedValidator
\item Expander2
\item Fc2Tools
\item GEAR
\item ImProve
\item Java Pathfinder
\item LLBMC
\item LTSA
\item LTSmin
\item MCMAS
\item mCRL2
\item MRMC
\item ompca, OpenMP C Analysis
\item PAT
\item PRISM
\item ProB
\item Reactis Tester
\item RED
\item SAL
\item SATABS
\item SATMC
\item SLMC
\item SPIN
\item Spot
\item TAPAAL
\item TAPAs
\item UPPAAL
\item ROMEO
\end{enumerate}

	\section{Zaključak}
	\label{sec:zakljucak}

Greške su sastavni deo svakog rada i tako se i u računarstvu javljaju kao svuda. Glavni cilj je iste te greške detektovati i otkloniti na vreme, pre nego što postanu pretnja po čitav sistem. Efikasna i formalna verifikacija sistema, na prvom mestu konkurentnih, je jako važna. Temporalne logike imaju jako bitnu ulogu u kreiranju sistema koje se bave istim. Temeljno razumevanje ovih logika je krucijalno za bilo kakvo dalje istraživanje oblasti verifikacije sistema. Ovi sistemi su ekspanziji, njihovom razvoju se sve više i više pridaje na značaju, i teži se ka tome da se svi ulazi/izlazi pokriju i ispravno provere. Naravno i treba posvetiti pažnju već postojećim alatima, kao što je ESBMC, i diskutovati o prednostima i manama istih.


	\addcontentsline{toc}{section}{Literatura}
	\appendix
	\bibliography{seminarski} 
	\bibliographystyle{plain}


	\end{document}
